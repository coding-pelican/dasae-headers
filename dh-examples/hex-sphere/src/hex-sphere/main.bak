// #include "dh/prl.h"
// #include "dh/math/common.h"
// #include "dh/math/vec.h"

// typedef struct RGB {
//     u8 r, g, b;
// } RGB;
// use_Sli$(RGB);

// typedef struct Screen {
//     m_V2i32 dimension;
//     Sli$RGB color_buffer;
//     Sli$f64 depth_buffer;
// } Screen;
// fn_(Screen_getRGB(const Screen* self, i32 x, i32 y), RGB) {
//     if (0 <= x && x < self->dimension.x && 0 <= y && y < self->dimension.y) {
//         return Sli_getAt(self->color_buffer, y * self->dimension.x + x);
//     }
//     return (RGB){ 0, 0, 0 };
// }
// fn_(Screen_setRGB(Screen* self, i32 x, i32 y, RGB color), void) {
//     if (0 <= x && x < self->dimension.x && 0 <= y && y < self->dimension.y) {
//         Sli_setAt(self->color_buffer, y * self->dimension.x + x, color);
//     }
// }

// #include "dh/mem/Allocator.h"

// // 정이십면체 기본 정점 (단위 구 위)
// typedef struct IcoSphere IcoSphere;
// use_Sli$(m_V3f64);
// typedef struct Triangle {
//     i32 indices[3];
// } Triangle;
// use_Sli$(Triangle);
// fn_(Triangle_from(i32 a, i32 b, i32 c), Triangle) {
//     return (Triangle){ { a, b, c } };
// }
// struct IcoSphere {
//     Sli$m_V3f64  vertices;
//     Sli$Triangle triangles;
// };
// use_Err$(IcoSphere);
// #define IcoSphere_vertex_count   (12)
// #define IcoSphere_triangle_count (20)

// func((IcoSphere_init(mem_Allocator allocator))(Err$IcoSphere)$guard) {
//     var ico = make$(IcoSphere);

//     var vertices = meta_cast$(Sli$m_V3f64, try_(mem_Allocator_alloc(allocator, typeInfo$(m_V3f64), IcoSphere_vertex_count)));
//     errdefer_($ignore_capture, mem_Allocator_free(allocator, anySli(vertices)));
//     let t          = math_f64_golden_ratio;
//     let s          = math_sqrt(1 + t * t);
//     let p_vertices = (Arr$$(IcoSphere_vertex_count, m_V3f64))Arr_init({
//         [0]  = m_V3f64_from(-1, t, 0),
//         [1]  = m_V3f64_from(1, t, 0),
//         [2]  = m_V3f64_from(-1, -t, 0),
//         [3]  = m_V3f64_from(1, -t, 0),
//         [4]  = m_V3f64_from(0, -1, t),
//         [5]  = m_V3f64_from(0, 1, t),
//         [6]  = m_V3f64_from(0, -1, -t),
//         [7]  = m_V3f64_from(0, 1, -t),
//         [8]  = m_V3f64_from(t, 0, -1),
//         [9]  = m_V3f64_from(t, 0, 1),
//         [10] = m_V3f64_from(-t, 0, -1),
//         [11] = m_V3f64_from(-t, 0, 1),
//     });
//     // Normalize vertices to unit sphere
//     for_slice_indexed (vertices, vertex, i) {
//         *vertex = m_V3f64_scale(*Arr_at(p_vertices, i), 1 / s);
//     }
//     ico.vertices = vertices;

//     var triangles = meta_cast$(Sli$Triangle, try_(mem_Allocator_alloc(allocator, typeInfo$(Triangle), IcoSphere_triangle_count)));
//     errdefer_($ignore_capture, mem_Allocator_free(allocator, anySli(triangles)));
//     let faces = (Arr$$(IcoSphere_triangle_count, Triangle))Arr_init({
//         [0]  = Triangle_from(0, 11, 5),
//         [1]  = Triangle_from(0, 5, 1),
//         [2]  = Triangle_from(0, 1, 7),
//         [3]  = Triangle_from(0, 7, 10),
//         [4]  = Triangle_from(0, 10, 11),
//         [5]  = Triangle_from(1, 5, 9),
//         [6]  = Triangle_from(5, 11, 4),
//         [7]  = Triangle_from(11, 10, 2),
//         [8]  = Triangle_from(10, 7, 6),
//         [9]  = Triangle_from(7, 1, 8),
//         [10] = Triangle_from(3, 9, 4),
//         [11] = Triangle_from(3, 4, 2),
//         [12] = Triangle_from(3, 2, 6),
//         [13] = Triangle_from(3, 6, 8),
//         [14] = Triangle_from(3, 8, 9),
//         [15] = Triangle_from(4, 9, 5),
//         [16] = Triangle_from(2, 4, 11),
//         [17] = Triangle_from(6, 2, 10),
//         [18] = Triangle_from(8, 6, 7),
//         [19] = Triangle_from(9, 8, 1),
//     });
//     for_slice_indexed (triangles, triangle, i) {
//         *triangle = *Arr_at(faces, i);
//     }
//     ico.triangles = triangles;

//     return_ok(ico);
// } $unguarded;

// func((IcoSphere_fini(IcoSphere* const self, mem_Allocator allocator))(void)) {
//     mem_Allocator_free(allocator, anySli(self->vertices));
//     mem_Allocator_free(allocator, anySli(self->triangles));
// }

// // Subdivision으로 Bucky-ball 생성 (N 레벨)
// IcoSphere* IcoSphere_subdivide(IcoSphere* ico, int subdivisions) {
//     for (int s = 0; s < subdivisions; s++) {
//         IcoSphere* new_ico = calloc(1, sizeof(IcoSphere));

//         // 각 삼각형을 4개로 분할
//         new_ico->vertex_count   = ico->vertex_count + ico->triangle_count * 3 / 2;
//         new_ico->triangle_count = ico->triangle_count * 4;
//         new_ico->vertices       = malloc(new_ico->vertex_count * sizeof(m_V3f64));
//         new_ico->triangles      = malloc(new_ico->triangle_count * 3 * sizeof(int));

//         // 기존 정점 복사
//         memcpy(new_ico->vertices, ico->vertices, ico->vertex_count * sizeof(m_V3f64));

//         int vertex_idx   = ico->vertex_count;
//         int triangle_idx = 0;

//         // 각 삼각형 세분화
//         for (int t = 0; t < ico->triangle_count; t++) {
//             int v0 = ico->triangles[t * 3];
//             int v1 = ico->triangles[t * 3 + 1];
//             int v2 = ico->triangles[t * 3 + 2];

//             // 중점 생성 및 정규화
//             m_V3f64 m0 = normalize(midpoint(ico->vertices[v0], ico->vertices[v1]));
//             m_V3f64 m1 = normalize(midpoint(ico->vertices[v1], ico->vertices[v2]));
//             m_V3f64 m2 = normalize(midpoint(ico->vertices[v2], ico->vertices[v0]));

//             int mv0 = vertex_idx++;
//             int mv1 = vertex_idx++;
//             int mv2 = vertex_idx++;

//             new_ico->vertices[mv0] = m0;
//             new_ico->vertices[mv1] = m1;
//             new_ico->vertices[mv2] = m2;

//             // 4개 새 삼각형
//             new_ico->triangles[triangle_idx++] = v0;
//             new_ico->triangles[triangle_idx++] = mv0;
//             new_ico->triangles[triangle_idx++] = mv2;

//             new_ico->triangles[triangle_idx++] = v1;
//             new_ico->triangles[triangle_idx++] = mv1;
//             new_ico->triangles[triangle_idx++] = mv0;

//             new_ico->triangles[triangle_idx++] = v2;
//             new_ico->triangles[triangle_idx++] = mv2;
//             new_ico->triangles[triangle_idx++] = mv1;

//             new_ico->triangles[triangle_idx++] = mv0;
//             new_ico->triangles[triangle_idx++] = mv1;
//             new_ico->triangles[triangle_idx++] = mv2;
//         }

//         free(ico->vertices);
//         free(ico->triangles);
//         free(ico);
//         ico = new_ico;
//     }

//     return ico;
// }

// // 4x4 변환 행렬
// typedef struct {
//     float m[4][4];
// } Matrix4;

// // 행렬 곱셈
// Vec3 m_V3f64_transform(Vec3 v, Matrix4 mat) {
//     float w = mat.m[3][0] * v.x + mat.m[3][1] * v.y + mat.m[3][2] * v.z + mat.m[3][3];
//     return (Vec3){
//         (mat.m[0][0] * v.x + mat.m[0][1] * v.y + mat.m[0][2] * v.z + mat.m[0][3]) / w,
//         (mat.m[1][0] * v.x + mat.m[1][1] * v.y + mat.m[1][2] * v.z + mat.m[1][3]) / w,
//         (mat.m[2][0] * v.x + mat.m[2][1] * v.y + mat.m[2][2] * v.z + mat.m[2][3]) / w
//     };
// }

// // 회전 행렬
// Matrix4 rotation_matrix(float yaw, float pitch, float roll) {
//     float cy = cos(yaw), sy = sin(yaw);
//     float cp = cos(pitch), sp = sin(pitch);
//     float cr = cos(roll), sr = sin(roll);

//     Matrix4 mat = { { { cy * cr + sy * sp * sr, -cy * sr + sy * sp * cr, sy * cp, 0 },
//                       { cp * sr, cp * cr, -sp, 0 },
//                       { -sy * cr + cy * sp * sr, sy * sr + cy * sp * cr, cy * cp, 0 },
//                       { 0, 0, 0, 1 } } };

//     return mat;
// }

// // 투영 행렬 (Perspective)
// Matrix4 perspective_matrix(float fov, float aspect, float near, float far) {
//     float f  = 1.0 / tan(fov * 0.5);
//     float nf = 1.0 / (near - far);

//     Matrix4 mat = { { { f / aspect, 0, 0, 0 },
//                       { 0, f, 0, 0 },
//                       { 0, 0, (far + near) * nf, 2 * far * near * nf },
//                       { 0, 0, -1, 0 } } };

//     return mat;
// }

// // 3D → 2D 스크린 좌표
// Vec2 projectToScreen(Vec3 v, int width, int height) {
//     return (Vec2){
//         (v.x + 1.0) * width * 0.5,
//         (1.0 - v.y) * height * 0.5 // Y 반전
//     };
// }

// // Edge function for point-in-triangle test
// float edge_testPointInTriangle(Vec2 a, Vec2 b, Vec2 c) {
//     return (c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x);
// }

// // 삼각형 래스터라이제이션 with Z-버퍼
// void Screen_rasterizeTriangle(Screen* scr, Vec3 v0, Vec3 v1, Vec3 v2, RGB color) {
//     // 2D 투영
//     Vec2 p0 = project_to_screen(v0, scr->width, scr->height);
//     Vec2 p1 = project_to_screen(v1, scr->width, scr->height);
//     Vec2 p2 = project_to_screen(v2, scr->width, scr->height);

//     // Bounding box
//     int minX = fmax(0, fmin(p0.x, fmin(p1.x, p2.x)));
//     int maxX = fmin(scr->width - 1, fmax(p0.x, fmax(p1.x, p2.x)));
//     int minY = fmax(0, fmin(p0.y, fmin(p1.y, p2.y)));
//     int maxY = fmin(scr->height - 1, fmax(p0.y, fmax(p1.y, p2.y)));

//     // 삼각형 면적
//     float area = edge_function(p0, p1, p2);
//     if (area <= 0) {
//         return; // Back-face culling
//     }

//     // 각 픽셀 테스트
//     for (int y = minY; y <= maxY; y++) {
//         for (int x = minX; x <= maxX; x++) {
//             Vec2 p = { x + 0.5, y + 0.5 };

//             // Barycentric coordinates
//             float w0 = edge_function(p1, p2, p) / area;
//             float w1 = edge_function(p2, p0, p) / area;
//             float w2 = edge_function(p0, p1, p) / area;

//             // 삼각형 내부 테스트
//             if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
//                 // Z 보간
//                 float z = w0 * v0.z + w1 * v1.z + w2 * v2.z;

//                 // Z-버퍼 테스트
//                 int idx = y * scr->width + x;
//                 if (z < scr->zbuffer[idx]) {
//                     scr->zbuffer[idx] = z;
//                     setRGB(scr, x, y, color);
//                 }
//             }
//         }
//     }
// }

// // 간단한 Phong 조명 모델
// RGB calculateLighting(Vec3 normal, Vec3 light_dir, Vec3 view_dir, RGB base_color) {
//     // Normalize vectors
//     normal    = normalize(normal);
//     light_dir = normalize(light_dir);
//     view_dir  = normalize(view_dir);

//     // Ambient
//     float ambient = 0.2;

//     // Diffuse
//     float diffuse = fmax(0, dot_product(normal, light_dir)) * 0.6;

//     // Specular
//     Vec3  reflect  = reflect_vector(light_dir, normal);
//     float specular = pow(fmax(0, dot_product(reflect, view_dir)), 32) * 0.3;

//     // 최종 색상
//     float intensity = ambient + diffuse + specular;
//     return (RGB){
//         fmin(255, base_color.r * intensity),
//         fmin(255, base_color.g * intensity),
//         fmin(255, base_color.b * intensity)
//     };
// }

// // 면 법선 계산
// Vec3 calculateNormal(Vec3 v0, Vec3 v1, Vec3 v2) {
//     Vec3 edge1 = subtract(v1, v0);
//     Vec3 edge2 = subtract(v2, v0);
//     return normalize(cross_product(edge1, edge2));
// }

// void render_buckyball(Screen* scr, float rotation_x, float rotation_y) {
//     // Z-버퍼 초기화
//     for (int i = 0; i < scr->width * scr->height; i++) {
//         scr->zbuffer[i] = INFINITY;
//         scr->buffer[i]  = (RGB){ 20, 20, 40 }; // 배경색
//     }

//     // Bucky-ball 생성
//     IcoSphere* sphere = create_icosahedron();
//     sphere            = subdivide_icosphere(sphere, 2); // Level 2

//     // 변환 행렬 설정
//     Matrix4 model = rotation_matrix(rotation_y, rotation_x, 0);
//     Matrix4 view  = translation_matrix(0, 0, -3); // 카메라 위치
//     Matrix4 proj  = perspective_matrix(M_PI / 3, (float)scr->width / scr->height, 0.1, 100);

//     // 행렬 결합
//     Matrix4 mvp = matrix_multiply(proj, matrix_multiply(view, model));

//     // 조명 설정
//     Vec3 light_dir = { 0.3, 0.5, 0.7 };
//     Vec3 view_dir  = { 0, 0, 1 };

//     // 각 삼각형 렌더링
//     for (int t = 0; t < sphere->triangle_count; t++) {
//         int i0 = sphere->triangles[t * 3];
//         int i1 = sphere->triangles[t * 3 + 1];
//         int i2 = sphere->triangles[t * 3 + 2];

//         // 정점 변환
//         Vec3 v0 = transform_point(sphere->vertices[i0], mvp);
//         Vec3 v1 = transform_point(sphere->vertices[i1], mvp);
//         Vec3 v2 = transform_point(sphere->vertices[i2], mvp);

//         // 법선 계산 (월드 공간)
//         Vec3 n0     = transform_point(sphere->vertices[i0], model);
//         Vec3 n1     = transform_point(sphere->vertices[i1], model);
//         Vec3 n2     = transform_point(sphere->vertices[i2], model);
//         Vec3 normal = calculate_normal(n0, n1, n2);

//         // Pentagon vs Hexagon 색상 (간단한 구분)
//         RGB base_color;
//         if (t % 5 == 0) {
//             base_color = (RGB){ 200, 50, 50 }; // Pentagon - 빨강
//         } else {
//             base_color = (RGB){ 50, 150, 50 }; // Hexagon - 초록
//         }

//         // 조명 적용
//         RGB lit_color = calculate_lighting(normal, light_dir, view_dir, base_color);

//         // 삼각형 래스터라이즈
//         rasterize_triangle(scr, v0, v1, v2, lit_color);

//         // 와이어프레임 (선택사항)
//         if (SHOW_WIREFRAME) {
//             draw_line(scr, v0, v1, (RGB){ 255, 255, 255 });
//             draw_line(scr, v1, v2, (RGB){ 255, 255, 255 });
//             draw_line(scr, v2, v0, (RGB){ 255, 255, 255 });
//         }
//     }

//     free_icosphere(sphere);
// }

// // Bresenham 라인 알고리즘 (와이어프레임용)
// void Screen_drawLine(Screen* scr, Vec3 v0, Vec3 v1, RGB color) {
//     Vec2 p0 = project_to_screen(v0, scr->width, scr->height);
//     Vec2 p1 = project_to_screen(v1, scr->width, scr->height);

//     int x0 = p0.x, y0 = p0.y;
//     int x1 = p1.x, y1 = p1.y;

//     int dx  = abs(x1 - x0);
//     int dy  = abs(y1 - y0);
//     int sx  = (x0 < x1) ? 1 : -1;
//     int sy  = (y0 < y1) ? 1 : -1;
//     int err = dx - dy;

//     while (1) {
//         setRGB(scr, x0, y0, color);

//         if (x0 == x1 && y0 == y1) {
//             break;
//         }

//         int e2 = 2 * err;
//         if (e2 > -dy) {
//             err -= dy;
//             x0 += sx;
//         }
//         if (e2 < dx) {
//             err += dx;
//             y0 += sy;
//         }
//     }
// }

// int main() {
//     int width = 800, height = 600;

//     // 스크린 버퍼 할당
//     Screen scr;
//     scr.width   = width;
//     scr.height  = height;
//     scr.buffer  = malloc(width * height * sizeof(RGB));
//     scr.zbuffer = malloc(width * height * sizeof(float));

//     // 애니메이션 루프
//     float rotation_x = 0, rotation_y = 0;

//     while (1) {
//         // 렌더링
//         render_buckyball(&scr, rotation_x, rotation_y);

//         // 화면 출력 (플랫폼 의존적)
//         display_buffer(scr.buffer, width, height);

//         // 회전 업데이트
//         rotation_x += 0.01;
//         rotation_y += 0.02;

//         // 입력 처리
//         if (check_exit()) {
//             break;
//         }
//     }

//     free(scr.buffer);
//     free(scr.zbuffer);

//     return 0;
// }
